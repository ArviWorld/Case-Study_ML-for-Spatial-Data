---
title:  "Land cover classification with ML models in R"
subtitle: "Targeting the invasive species 'Gorse (Ulex europaeus)' on the Banks Peninsula in New Zealand"
author: "Dr. Hanna Meyer"
adapted_by: "Aravindh Venkatraman"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: 
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc: yes
    toc_depth: 6
  word_document: 
    toc: yes
    toc_depth: '6'
  html_document: default
  always_allow_html: yes
---

# Table of Contents

-   [Introduction](#introduction)
-   [Aim of this Project](#aim-of-this-project)
-   EDA
    -   [Data Loading](#data-loading)
    -   [Data Pre-processing](#data-pre-processing)
-   [Machine Learning Model](#machine-learning-model)
    -   [Random Forest](#random-forest)
    -   [XGBoost](#xgboost)
    -   [Support Vector Machine (SVM)](#support-vector-machine-svm)
-   [Results](#results)
    -   [Model Comparison](#model-comparison)
    -   [Confusion Matrices](#confusion-matrices)
    -   [Accuracy Comparison](#accuracy-comparison)
    -   [Spatial Predictions](#spatial-predictions)
-   [Discussion](#discussion)
    -   [Performance Comparison](#performance-comparison)
    -   [Strengths and Weaknesses](#strengths-and-weaknesses)
    -   [Uncertainty Insights](#uncertainty-insights)

# Introduction {#introduction}
The tutorial project demonstrates how to perform land cover classifications in R using machine learning algorithms such as Random Forests, XGBoost, and SVM, and compares their performance. This tutorial was presented by Dr. Hanna Meyer in July 2018. This tutorial has been adapted by Aravindh Venkatraman to include additional machine learning models for comparison. The focus is on land cover classification using Sentinel satellite data, specifically targeting the invasive species **gorse (*Ulex europaeus*)** on the Banks Peninsula. This plant was brought to New Zealand during the European settlement as a hedge plant and spreads into farmland since with negative consequences for the quality of the grassland. Each year millions of dollars are spent for its control. To develop management strategies, it's of high importance to map the distribution of such invasive plants. Since field samplings mean huge expenses, remote sensing methods are required for a spatially explicit monitoring. In this tutorial, we're going to use Sentinel satellite imagery from 2017 to map the current distribution on a section of the Banks Peninsula.

# Aim of this Project {#aim-of-this-project}
The technical aim of the tutorial project is to show land cover classifications, based on satellite data, can be performed in R using machine learning algorithms such as Random Forests, XGBoost and SVM. We show its performance and compare the results of the models.

# Methods {#methods}
This tutorial will guide you through the process of land cover (LC) classification using machine learning techniques in R. The focus is on classifying land cover types, particularly the invasive species **gorse (*Ulex europaeus*)**, using Sentinel satellite data. The steps include data loading, pre-processing, model training, and evaluation.

## Load required libraries
We select and load the libraries and packages that are needed for this LC classification project. The selected libraries provide functions for handling raster data, reading shapefiles, performing machine learning tasks, and visualizing results.

```{r setup, message=FALSE, warning=FALSE}

library(raster)
library(caret)
library(mapview)
library(sf)
library(randomForest)
library(xgboost)
library(e1071)
library(ModelMetrics)
library(ggplot2)
library(ingredients)
library(patchwork)
library(reshape2)
library(gridExtra)
library(dplyr)
library(rpart)
library(ranger)
library(terra)
library(DALEX)
library(vip)
library(pROC)
library(kableExtra)
library(RColorBrewer)

```

## Data Loading and Pre-processing
### Load and explore the data
To start with, let's load the Sentinel data as well as a shapefile of the training sites.

```{r load}

# Load Sentinel data
sentinel <- stack("D:\\Study\\Machine Learning\\Geostatistics\\R-Git\\Case-Study_ML-for-Spatial-Data\\Data\\sentinel2017.grd")

# Load training sites shapefile
training <- read_sf("D:\\Study\\Machine Learning\\Geostatistics\\R-Git\\Case-Study_ML-for-Spatial-Data\\Data\\trainingSites.shp")

# Visualize the Sentinel data
print(sentinel)
print(training)

```

**Overview of the data:** 
The Sentinel data is a stack of raster layers, The sentinel data subset for this tutorial contains the Sentinel channels 2-8 (visible and near infrared channels) as well as the NDVI and a yellowness index that was calculated as (red+green-blue)/(red+green+blue) as additional bands. We assume the yellowness index is valuable to distinguish the striking yellow color of the gorse from other vegetation.To get an idea about the band composition and spatial resolution, please check the Sentinel wikipedia documentation [here](https://en.wikipedia.org/wiki/Sentinel-2#Data_products). - The training sites are polygons that were digitized in QGIS on the basis of the Sentinel data using expert knowledge. The training dataset contains different land cover types, including gorse, grassland, and other vegetation types.

**Visualize the data:** 
We visualize the Sentinel data as a true color composite in the geographical context and overlay it with the polygons. Click on the polygons to see which land cover class is assigned to a respective polygon.

```{r visMV, echo=TRUE, warning=FALSE, message= FALSE}

# Visualize Sentinel data with training sites
viewRGB(sentinel, r=3, g=2, b=1, map.types = "Esri.WorldImagery") + 
  mapview(training)

```

### Data Pre-processing {#data-pre-processing}
We need to prepare the data for machine learning by extracting raster values for the training sites and merging them with the land cover class information from the shapefile. This step is crucial for training the machine learning model. Then, we split the data into training and test datasets to ensure that we can evaluate the model's performance on unseen data.

**Extract raster information** 
In order to train the Machine Learning model between the spectral properties and the land cover class, we first need to create a data frame that contains the spectral properties of the training sites as well as the corresponding class information. This data frame can be produced with the `extract` function. The resulting data frame contains the Sentinel data for each pixel overlayed by the polygons. This data frame then still needs to be merged with the information on the land cover class from the shapefile. This happens via the ID of the polygons which are given in the extracted data frame by the column "ID" and in the shapefile by the attribute "id".

```{r extract}

# Extract raster values for training sites
extr <- extract(sentinel, training, df=TRUE)

# Merge extracted data with training sites
extr <- merge(extr, training, by.x="ID", by.y="id")
kable(head(extr), caption = "Merged Data") %>%
  kable_styling(full_width = F, position = "left")

```

**Spliting data into training and test data** 
In order to keep data for a later (nearly) independent validation as well as to limit the number of data points so that the model training won't take long time, we split the total data set into 30% training data and 70% test data. Caret's `createDataPartition` takes care that the class distribution is the same in both datasets. We put the test data to the side and first only continue with the training data.

```{r split}

# Set seed for reproducibility
set.seed(100)

# Create training and test dataset
trainids <- createDataPartition(extr$Class, list=FALSE, p=0.3)
trainDat <- extr[trainids,]
testDat <- extr[-trainids,]

# Ensure Class is a factor and is at the same level
trainDat$Class <- factor(trainDat$Class)
testDat$Class <- factor(testDat$Class)

# Check the distribution of classes in training and test datasets
training_class = round(prop.table(table(trainDat$Class)) * 100, 2)
test_class = round(prop.table(table(testDat$Class)) * 100, 2)

kable(training_class, caption = "Training class balance") %>%
  kable_styling(full_width = F, position = "left")
kable(test_class, caption = "Test class balance") %>%
  kable_styling(full_width = F, position = "left")

```

**Visualize relationships** 
To get an idea about the relationships between the spectral Sentinel data and the land cover class, we can visualize how the different bands differs according to the land cover class. This helps us understand the distribution of different classes in the feature space.

```{r vis_relationships}

# Visualize relationships (box plot) between yellowness index and land cover class
ggplot(trainDat, aes(x = factor(Class), y = yellowness)) +
  geom_boxplot() +
  labs(title = "Yellowness Index by Land Cover Class",
       x = "Land Cover Class",
       y = "Yellowness Index") +
  theme_minimal()

# Visualize relationships (box plot) between NDVI and land cover class
ggplot(trainDat, aes(x = factor(Class), y = NDVI)) +
  geom_boxplot() +
  labs(title = "NDVI by Land Cover Class",
       x = "Land Cover Class",
       y = "NDVI") +
  theme_minimal()

```

The box plots show the distribution of the yellowness index and NDVI for each land cover class, providing insights into how these indices vary across different classes. The Gorse class features the highest "yellowness" values while all other land cover classes have considerably lower values.

**Feature Plot** 
We can also get an impression about the separability of the classes by creating a feature plot that visualizes the location of the training samples in a scatter plot of two Sentinel channels.

```{r featurePlot}

# Create feature plot to visualize relationships between Sentinel channels (B08 vs yellowness) and land cover class
ggplot(trainDat, aes(x = B08, y = yellowness, color = factor(Class))) +
  geom_point() +
  labs(title = "Feature Plot: Sentinel Band 8 vs Yellowness",
       x = "Sentinel Band 8 (NIR)",
       y = "Sentinel Band Yellowness",
       color = "Land Cover Class") +
  theme_minimal()
```

The feature plot shows the distribution of training samples in the feature space defined by Sentinel Band 8 (NIR) and the yellowness index. It helps us visualize how well the different land cover classes can be separated based on these features. The other feat Here the Gorse class features the highest "yellowness" values while all other land cover classes have considerably lower values. With view to the feature plot note that there is only low separability considering Sentinel channel 3 and 4 (green and red) but high separability when channel 8 (near infrared) or the yellowness index is included.

# Machine Learning Model {#machine-learning-model}
The split data is now ready for training machine learning models. We will implement three different algorithms: Random Forest, XGBoost, and Support Vector Machine (SVM). Each model will be trained on the training dataset and evaluated on the test dataset.

**Selecting predictor and response variable** 
Before building the ML models, we need to select the predictor variables (the Sentinel bands and indices) and the response variable (the land cover class). The response variable is categorical, while the predictor variables are continuous. From the data, we select all the information from the sentinel raster data as the predictor variables and the land cover class as the response variable.

```{r select_vars}

# Select predictor variables (Sentinel bands and indices)
predictors <- c("B02", "B03", "B04", "B05", "B06", "B07", "B08", "NDVI", "yellowness")

# Select response variable (land cover class)
response <- 'Class'

```

## Random Forest {#random-forest}
Random Forest is a popular ensemble learning method that constructs multiple decision trees and merges them together to get a more accurate and stable prediction. It is particularly effective for classification tasks and suits this LC classification analysis.

Training the Random Forest model using the `randomForest` package in R. The model is trained on the training dataset, and we can visualize the variable importance to understand which features contribute most to the classification. We use the `train` function from the `caret` package to train the model with 10-fold cross-validation for hyperparameter tuning.

```{r random_forest}

# Ensure response is a factor
trainDat[, response] <- as.factor(trainDat[, response])

# Define hyperparameter tuning grid 
rf_grid <- expand.grid(
  mtry = c(2, 3, 4),  # Number of variables randomly sampled at each split
  splitrule = "gini", # Splitting rule
  min.node.size = c(1, 5) # Minimum size of terminal nodes
)

# Setting train control
control <- trainControl(
  method = "cv",         # k-fold CV
  number = 10,           # 10-fold
  summaryFunction = multiClassSummary,  # for multiclass metrics
  classProbs = TRUE,
  savePredictions = "final"
)

# Train Random Forest model
set.seed(100)
model_rf <- train(trainDat[, predictors], trainDat[, response], 
                  method = "rf", 
                  trControl = control, 
                  importance = TRUE)

```

```{r rf_summary, echo=TRUE, message=FALSE}

# Print model summary
kable(model_rf$results, caption = "Random Forest Model Results") %>%
  kable_styling(full_width = F, position = "left")

# Extract variable importance
importance_df <- varImp(model_rf)$importance

# Add variable names as a column
importance_df$Variable <- rownames(importance_df)

# Compute overall importance (if multiple classes)
importance_df$Overall <- rowMeans(importance_df[, sapply(importance_df, is.numeric)])

# Round and sort in descending order
importance_df <- importance_df %>%
  mutate(Overall = round(Overall, 3)) %>%
  arrange(desc(Overall))  # High to low

# View top variables
kable(importance_df, caption = "Variable Importance for Random Forest Model") %>%
  kable_styling(full_width = F, position = "left")
  
# Plot variable importance
ggplot(importance_df, aes(x = reorder(Variable, Overall), y = Overall)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Variable Importance (High to Low)",
       x = "Variable", y = "Importance Score") +
  theme_minimal()

```

The Random Forest model has been trained successfully, and we can see the variable importance scores for each predictor variable. The variable importance plot shows which features contribute most to the classification task, with the XXX being among the most important predictors.

**Predicting the test data with confusion matrix and scoring metrics**
To evaluate the performance of the Random Forest model on the test dataset, we can create a confusion matrix and calculate scoring metrics such as accuracy, sensitivity, and specificity. The confusion matrix provides insights into how well the model performs on the test dataset.

```{r rf_confusion_matrix, echo=TRUE, warning=FALSE}

# Predict on the test dataset
predictions_rf <- predict(model_rf, newdata = testDat[, predictors])

# Extract the levels from the training data response
true_levels <- levels(trainDat[[response]])

# Convert both predicted and actual responses to factors with the same levels
predictions_rf <- factor(predictions_rf, levels = true_levels)
actual_rf <- factor(testDat[[response]], levels = true_levels)

# Construct the confusion matrix
confusion_rf <- caret::confusionMatrix(predictions_rf, actual_rf)

# Plot confusion matrix
cm_plot_rf <- ggplot(as.data.frame(confusion_rf$table), aes(x = Reference, y = Prediction)) +
  geom_tile(aes(fill = Freq), color = "white") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(label = Freq), color = "black") +
  labs(title = "Confusion Matrix for Random Forest Model",
       x = "Reference Class",
       y = "Predicted Class") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

cm_plot_rf

# Print scoring metrics
kable(confusion_rf$overall, caption = "Scoring Metrics for Random Forest Model") %>%
  kable_styling(full_width = F, position = "left")

# Print sensitivity and specificity for each class
kable(confusion_rf$byClass, caption = "Sensitivity and Specificity for Random Forest Model") %>%
  kable_styling(full_width = F, position = "left")

```

**Results** 
Confusion Matrix and scoring metrics provide insights into the performance of the Random Forest model on the test dataset. The confusion matrix shows how many instances were correctly classified for each land cover class, while the scoring metrics (accuracy, sensitivity, specificity) quantify the model's overall performance.

## XGBoost {#xgboost}
XGBoost (Extreme Gradient Boosting) is a powerful and efficient implementation of gradient boosting that is widely used for classification tasks. It is known for its speed and performance, making it suitable for large datasets. Training the XGBoost model using the `xgboost` package in R. The model is trained on the training dataset, and we can visualize the variable importance to understand which features contribute most to the classification. We use the `train` function from the `caret` package to train the model with 10-fold cross-validation for hyperparameter tuning.

``` {r xgboost}

# Ensure response is a factor
trainDat[, response] <- as.factor(trainDat[, response])

# Define hyperparameter tuning grid 
xgb_grid <- expand.grid(
  nrounds = 100,
  max_depth = 6,
  eta = 0.3,
  gamma = 0,
  colsample_bytree = 1,
  min_child_weight = 1,
  subsample = 1
)

# Setting train control
control <- trainControl(
  method = "cv",         # k-fold CV
  number = 10,           # 10-fold
  summaryFunction = multiClassSummary,  # for multiclass metrics
  classProbs = TRUE,
  savePredictions = "final",
  verboseIter = FALSE
)

# Train the XGBoost model using caret
set.seed(100)
model_xgb <- train(x = trainDat[, predictors],
                   y = trainDat[, response],
                   method = "xgbTree",
                   trControl = control,
                   tuneGrid = xgb_grid)
  
```

``` {r xgb_summary, echo=TRUE, message=FALSE}

# Print model summary
kable(model_xgb$results, caption = "XGBoost Model Results") %>%
  kable_styling(full_width = F, position = "left")

# Extract variable importance
importance_xgb <- xgb.importance(feature_names = predictors, model = model_xgb$finalModel)

# Convert importance to a data frame
importance_df_xgb <- as.data.frame(importance_xgb)
importance_df_xgb <- importance_df_xgb %>%
  mutate(Variable = reorder(Feature, Gain)) %>%
  arrange(desc(Gain))

# Check the summary of the importance data frame
kable(importance_df_xgb, caption = "Variable Importance for XGBoost Model") %>%
  kable_styling(full_width = F, position = "left")

# Visualize variable importance using ggplot2
ggplot(importance_df_xgb, aes(x = Variable, y = Gain)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Variable Importance (High to Low)",
       x = "Variable", y = "Importance Score") +
  theme_minimal()

```

**Predicting the test data with confusion matrix and scoring metrics* 
To evaluate the performance of the Random Forest model on the test dataset, we can create a confusion matrix and calculate scoring metrics such as accuracy, sensitivity, and specificity. The confusion matrix provides insights into how well the model performs on the test dataset.

```{r xgb_confusion_matrix}

# Predict on the test dataset
predictions_xgb <- predict(model_xgb, newdata = testDat[, predictors])

# Extract the levels from the training data response
true_levels_xgb <- levels(trainDat[[response]])

# Convert both predicted and actual responses to factors with the same levels
predictions_xgb <- factor(predictions_xgb, levels = true_levels_xgb)
actual_xgb <- factor(testDat[[response]], levels = true_levels_xgb)

# Now create the confusion matrix
confusion_xgb <- caret::confusionMatrix(predictions_xgb, actual_xgb)

# Plot confusion matrix
cm_plot_xgb <- ggplot(as.data.frame(confusion_xgb$table), aes(x = Reference, y = Prediction)) +
  geom_tile(aes(fill = Freq), color = "white") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(label = Freq), color = "black") +
  labs(title = "Confusion Matrix for XGBoost Model",
       x = "Reference Class",
       y = "Predicted Class") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

cm_plot_xgb

# Print scoring metrics
kable(confusion_xgb$overall, caption = "Scoring Metrics for XGBoost Model") %>%
  kable_styling(full_width = F, position = "left")

# Print sensitivity and specificity for each class
kable(confusion_xgb$byClass, caption = "Sensitivity and Specificity for XGBoost Model") %>%
  kable_styling(full_width = F, position = "left")

```

**Results** 
Confusion Matrix and scoring metrics provide insights into the performance of the XGBoost model on the test dataset. The confusion matrix shows how many instances were correctly classified for each land cover class, while the scoring metrics (accuracy, sensitivity, specificity) quantify the model's overall performance.

## Support Vector Machine (SVM) {#support-vector-machine-svm}
Support Vector Machine (SVM) is a supervised learning algorithm that can be used for classification tasks. It works by finding the hyperplane that best separates the classes in the feature space. SVM is effective in high-dimensional spaces and is suitable for this LC classification analysis. Training the SVM model using the `e1071` package in R. The model is trained on the training dataset, and we can visualize the variable importance to understand which features contribute most to the classification. We use the `train` function from the `caret` package to train the model with 10-fold cross-validation for hyperparameter tuning.

```{r svm, echo=TRUE, warning=FALSE}

# Ensure response is a factor
trainDat[, response] <- as.factor(trainDat[, response])

# Define hyperparameter tuning grid 
svm_grid <- expand.grid(
  sigma = 0.1,          # Kernel parameter
  C = 1                 # Cost parameter
)

# Setting train control
control <- trainControl(
  method = "cv",         # k-fold CV
  number = 10,           # 10-fold
  summaryFunction = multiClassSummary,  # for multiclass metrics
  classProbs = TRUE,
  savePredictions = "final"
)

# Train Support Vector Machine (SVM) model
set.seed(100)
model_svm <- train(trainDat[, predictors], trainDat[, response], 
                   method = "svmRadial", 
                   trControl = trainControl(method = "cv", number = 10), 
                   tuneGrid = svm_grid)


```

```{r svm_summary, echo=TRUE, message=FALSE}

# Print model summary
kable(model_svm$results, caption = "Support Vector Machine Model Results") %>%
  kable_styling(full_width = F, position = "left")

# Extract variable importance
importance_svm <- varImp(model_svm)$importance

# Add variable names as a column
importance_svm$Variable <- rownames(importance_svm)

# Compute overall importance (if multiple classes)
importance_svm$Overall <- rowMeans(importance_svm[, sapply(importance_svm, is.numeric)])

# Round and sort in descending order
importance_svm <- importance_svm %>%
  mutate(Overall = round(Overall, 3)) %>%
  arrange(desc(Overall))  # High to low

# Print top variables
kable(importance_svm, caption = "Variable Importance for Support Vector Machine Model") %>%
  kable_styling(full_width = F, position = "left")

# Plot variable importance
ggplot(importance_svm, aes(x = reorder(Variable, Overall), y = Overall)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Variable Importance (High to Low)",
       x = "Variable", y = "Importance Score") +
  theme_minimal()

```

**Predicting the test data with confusion matrix and scoring metrics**
To evaluate the performance of the Random Forest model on the test dataset, we can create a confusion matrix and calculate scoring metrics such as accuracy, sensitivity, and specificity. The confusion matrix provides insights into how well the model performs on the test dataset.

```{r svm_confusion_matrix}

# Predict on the test dataset
predictions_svm <- predict(model_svm, newdata = testDat[, predictors],
                           probability = TRUE)

# Extract the levels from the training data response
true_levels_svm <- levels(trainDat[[response]])

# Convert both predicted and actual responses to factors with the same levels
predictions_svm <- factor(predictions_svm, levels = true_levels_svm)
actual_svm <- factor(testDat[[response]], levels = true_levels_svm)

# Construct the confusion matrix
confusion_svm <- caret::confusionMatrix(predictions_svm, actual_svm)

# Plot confusion matrix
cm_plot_svm <- ggplot(as.data.frame(confusion_svm$table), aes(x = Reference, y = Prediction)) +
  geom_tile(aes(fill = Freq), color = "white") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(label = Freq), color = "black") +
  labs(title = "Confusion Matrix for Support Vector Machine Model",
       x = "Reference Class",
       y = "Predicted Class") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot Confusion Matrix
cm_plot_svm

# Print scoring metrics
kable(confusion_svm$overall, caption = "Scoring Metrics for Support Vector Machine Model") %>%
  kable_styling(full_width = F, position = "left")

# Print sensitivity and specificity for each class
kable(confusion_svm$byClass, caption = "Sensitivity and Specificity for Support Vector Machine Model") %>%
  kable_styling(full_width = F, position = "left")

```

**Results** 
Confusion Matrix and scoring metrics provide insights into the performance of the Support Vector Machine (SVM) model on the test dataset. The confusion matrix shows how many instances were correctly classified for each land cover class, while the scoring metrics (accuracy, sensitivity, specificity) quantify the model's overall performance.

## Results & Discussions {#results & discussions}
### Confusion matrices
Comparing the Confusion matrices of the three models, we can see how well each model performed in classifying the land cover types. The confusion matrices show the number of true positives, false positives, true negatives, and false negatives for each class. This allows us to assess the strengths and weaknesses of each model in terms of classification accuracy.

```{r confusion_matrices, echo=FALSE, message=FALSE}

# Create a list of confusion matrices for each model
cm_plot_rf
cm_plot_xgb
cm_plot_svm

```

**Discussion**


### Comparison and plots of Scoring metrics 
Compare the scoring metrics (precision, f1score, recall, accuracy, sensitivity, specificity) of the three models to see which model performed best overall. The accuracy metric indicates the overall correctness of the model, while sensitivity and specificity provide insights into how well the model identifies each class.

```{r scoring_metrics, echo=FALSE, message=FALSE}

# Create a data frame to hold the scoring metrics for each model from the test dataset
scoring_df <- data.frame(
  Model = c("Random Forest", "XGBoost", "Support Vector Machine"),
  Accuracy = c(
    confusion_rf$overall['Accuracy'],
    confusion_xgb$overall['Accuracy'], 
    confusion_svm$overall['Accuracy']),
  Kappa = c(
    confusion_rf$overall['Kappa'], 
    confusion_xgb$overall['Kappa'], 
    confusion_svm$overall['Kappa']),
  Precision = c(
    mean(confusion_rf$byClass[,"Precision"]), 
    mean(confusion_xgb$byClass[,"Precision"]),
    mean(confusion_svm$byClass[,"Precision"])),
  Sensitivity = c(
    mean(confusion_rf$byClass[,"Sensitivity"]),
    mean(confusion_xgb$byClass[,"Sensitivity"]),
    mean(confusion_svm$byClass[,"Sensitivity"])),
  Specificity = c(
    mean(confusion_rf$byClass[,"Specificity"]),
    mean(confusion_xgb$byClass[,"Specificity"]),
    mean(confusion_svm$byClass[,"Specificity"])),
  F1_Score = c(
    mean(confusion_rf$byClass[,"F1"]), 
    mean(confusion_xgb$byClass[,"F1"]), 
    mean(confusion_svm$byClass[,"F1"]))
)

# Print the scoring metrics data frame
kable(scoring_df, caption = "Scoring Metrics for Each Model") %>%
  kable_styling(full_width = F, position = "left")

# Set the order for the plot
scoring_df$Model <- factor(scoring_df$Model,
                           levels = 
                             c('Random Forest',
                             'XGBoost',
                             'Support Vector Machine'))

# Plot the scoring metrics for each model
scoring_df_long <- melt(scoring_df, id.vars = "Model")
ggplot(scoring_df_long, aes(x = Model, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Scoring Metrics Comparison between the models",
       x = "Model", y = "Score") +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

**Discussions - Model Performance**
The scoring metrics provide a comprehensive overview of the performance of each model. The Random Forest model achieved the highest accuracy, followed closely by XGBoost and SVM. The precision and sensitivity scores indicate that Random Forest and XGBoost performed well in identifying the gorse class, while SVM had slightly lower scores. The F1 score, which balances precision and recall, also shows that Random Forest and XGBoost outperformed SVM.

### Uncertainly Analysis
**1. DALEX Uncertainity Analysis**
To gain insights into the uncertainty of the model predictions, we can use the DALEX package to create an explainer for each model. This allows us to analyze the model's predictions and understand how different features contribute to the uncertainty in the predictions.

```{r uncertainty_analysis, echo=FALSE, message=FALSE}

# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")

# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf, 
                               data = testDat[, predictors], 
                               y = testDat$Class, 
                               label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb, 
                                data = testDat[, predictors], 
                                y = testDat$Class, 
                                label = "XGBoost")
explainer_svm <- DALEX::explain(model = model_svm, 
                                data = testDat[, predictors], 
                                y = testDat$Class, 
                                label = "Support Vector Machine")

# Residual performance (classification)
mp_rf <- model_performance(explainer_rf)
mp_xgb <- model_performance(explainer_xgb)
mp_svm <- model_performance(explainer_svm)

# Plot ROC or accuracy
plot(mp_rf)
plot(mp_xgb)
plot(mp_svm)

```
8.1. Probability-based Entropy Maps (for uncertainty)

8.2. Model Disagreement Map

### Predicted Maps by the Model
To visualize the spatial predictions made by each model, we can create maps that show the predicted land cover classes across the study area. This allows us to see how well each model captures the spatial distribution of different land cover types.




